(in-package nock)
(in-readtable impl)

(defun boolify (value)
  (if value 0 1))

(defun tree-elt (idx tree)
  (case idx
    (1		tree)
    (2		(car tree))
    (3		(cdr tree))
    (otherwise	(multiple-value-bind (quotent remainder)
                    (floor idx 2)
                  (tree-elt (+ 2 remainder) (tree-elt quotent tree))))))
(defun (setf tree-elt) (new idx tree)
  (case idx
    (1		new)
    (2		(setf (car tree) new))
    (3		(setf (cdr tree) new))
    (otherwise	(multiple-value-bind (quotent remainder)
                    (floor idx 2)
                  (setf (tree-elt (+ 2 remainder) (tree-elt quotent tree)) new)))))

(defmacro lockf-formula (place)
  `(if (functionp ,place)
       ,place
       (setf ,place (lock-formula ,place))))

(defun lock (term)
  (let ((noun (nerm-noun term)))
    (ecase (nerm-op term)
      (*	(funcall (lockf-formula (cdr noun)) (car noun)))

      (?	(boolify (consp noun)))
      (+	(1+ noun))
      (=	(boolify (equal (car noun) (cdr noun))))
      (/	(tree-elt (car noun) (cdr noun))))))

(defun lock-formula (noun)
  (ematch noun
    ([(place b) (place c)]
      when (consp b)		$ 19	(lambda (a)
                                          (cons (funcall (lockf-formula b) a)
                                                (funcall (lockf-formula c) a))))
    ([0 b]			$ 21	(lambda (a)
                                          (tree-elt b a)))
    ([1 b]			$ 22	(constantly b))
    ([2 (place b) (place c)]	$ 23	(lambda (a)
                                          (funcall (lock-formula (funcall (lockf-formula c) a))
                                                   (funcall (lockf-formula b) a))))
    ([3 (place b)]		$ 24	(lambda (a)
                                          (boolify (consp (funcall (lockf-formula b) a)))))
    ([4 (place b)]		$ 25	(lambda (a)
                                          (1+ (funcall (lockf-formula b) a))))
    ([5 (place b)]		$ 26	(lambda (a)
                                          (let ((noun (funcall (lockf-formula b) a)))
                                            (boolify (equal (car noun) (cdr noun))))))
    ([6 (place b)
        (place c)
        (place d)]		$ 28	(lambda (a)
                                          (if (zerop (funcall (lockf-formula b) a))
                                              (funcall (lockf-formula c) a)
                                              (funcall (lockf-formula d) a))))
    ([7 (place b) (place c)]	$ 29	(lambda (a)
                                          (funcall (lockf-formula c)
                                                   (funcall (lockf-formula b) a))))
    ([8 (place b) (place c)]	$ 30	(lambda (a)
                                          (funcall (lockf-formula c)
                                                   (let ((product (funcall (lockf-formula b) a)))
                                                     [product a]))))
    ([9 b (place c)]		$ 31	(lambda (a)
                                          (funcall (lambda (core)
                                                     (funcall (lockf-formula
                                                               (tree-elt b core))
                                                              core))
                                                   (funcall (lockf-formula c) a))))
    ([10 [_ (place c)]
         (place d)]		$ 32	(lambda (a)
                                          (funcall (lockf-formula c) a)
                                          (funcall (lockf-formula d) a)))
    ;; TODO jets
    ([10 _ (place c)]		$ 33	(lambda (a)
                                          (funcall (lockf-formula c) a)))))

(in-package nock)
(in-readtable impl)

(defun boolify (value)
  (if value 0 1))

(defun tree-elt (idx tree)
  (case idx
    (1		tree)
    (2		(car tree))
    (3		(cdr tree))
    (otherwise	(multiple-value-bind (quotent remainder)
                    (floor idx 2)
                  (tree-elt (+ 2 remainder) (tree-elt quotent tree))))))

(defun lock (term)
  (let ((noun (nerm-noun term)))
    (ecase (nerm-op term)
      (*	(funcall (lock-formula (cdr noun)) (car noun)))

      (?	(boolify (consp noun)))
      (+	(1+ noun))
      (=	(boolify (equal (car noun) (cdr noun))))
      (/	(tree-elt (car noun) (cdr noun))))))

(defun lock-formula (noun)
  (ematch noun
    ([b c] when (consp b)	$ 19	(lambda (a)
                                          (cons (funcall (lock-formula b) a)
                                                (funcall (lock-formula c) a))))
    ([0 b]			$ 21	(lambda (a)
                                          (tree-elt b a)))
    ([1 b]			$ 22	(constantly b))
    ([2 b c]			$ 23	(lambda (a)
                                          (let ((noun (cons (funcall (lock-formula b) a)
                                                            (funcall (lock-formula c) a))))
                                            (funcall (lock-formula (cdr noun)) (car noun)))))
    ([3 b]			$ 24	(lambda (a)
                                          (boolify (consp (funcall (lock-formula b) a)))))
    ([4 b]			$ 25	(lambda (a)
                                          (1+ (funcall (lock-formula b) a))))
    ([5 b]			$ 26	(lambda (a)
                                          (let ((noun (funcall (lock-formula b) a)))
                                            (boolify (equal (car noun) (cdr noun))))))
    ([6 b c d]			$ 28	(lambda (a)
                                          (if (zerop (funcall (lock-formula b) a))
                                              (funcall (lock-formula c) a)
                                              (funcall (lock-formula d) a))))
    ([7 b c]			$ 29	(lambda (a)
                                          (funcall (lock-formula c)
                                                   (funcall (lock-formula b) a))))
    ([8 b c]			$ 30	(lambda (a)
                                          (funcall (lock-formula c)
                                                   (let ((product (funcall (lock-formula b) a)))
                                                     [product a]))))
    ([9 b c]			$ 31	(lambda (a)
                                          (funcall (lambda (core)
                                                     (funcall (lock-formula
                                                               (tree-elt b core))
                                                              core))
                                                   (funcall (lock-formula c) a))))
    ([10 [_ c] d]		$ 32	(lambda (a)
                                          (funcall (lock-formula c) a)
                                          (funcall (lock-formula d) a)))
    ;; TODO jets
    ([10 _ c]			$ 33	(lambda (a)
                                          (funcall (lock-formula c) a)))))
